Solution integration pipelines
- [Instructor] Once the model is ready and benchmarked, it needs to be integrated with the non ML part of the solution. In this chapter, we will focus on the processes and best practices for solution integration. ML models do not work standalone. They need to be embedded into other code to deliver end-to-end solutions. This requires integration with other code like APIs, UIs, databases, and microservices. How do we go about doing this integration? Let's look at the solution integration pipeline now. As seen before, we trained the model using input data from the feature store and hyper parameters. We then stored the model in the model registry. Now, the model and its pre-processing and post-processing code is in the form of a notebook. It needs to be converted into a software form that is suitable for integration. We call this step, notebook to software. This method produces the model in an executable form. This is then regression tested to make sure that the model still continues to perform as its baseline notebook form. This produces an ML service that is ready for integration. We call it a service here but it could be a library or a function. On the other hand, the non ML code evolves independently. The non ML code is tested with other functions and it gets ready for integration. The ML service is then integrated into the non counterpart and integration tested. The entire solution is then performance tested to make sure that the solution as a whole meets the requirements of the project. This is then packaged and is ready for delivery. The package contains both the model in its executable form and the non ML code.