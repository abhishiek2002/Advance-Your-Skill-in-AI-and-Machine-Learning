Solution integration patterns
- When do we integrate the ML and non-ML parts of the solution? Let's look at the options available in this video. The ML and non-ML parts of the solution evolves simultaneously in incremental cycles. Integrating code is always cumbersome, if the process is not well managed. Ensuring integration with stable versions of the software will help avoid sub prices later during deployment. Let's look at a sample ML and non-ML pipeline. On the ML side, we start with the model version 2.0 and the corresponding ML service version 2.0, we then evolve this model with retraining and come up with a model version 3.0. This goes through the notebook to software process to produce ML service 3.0. On the other side, we start with the non-ML version 4.0. It goes through development and testing processes to produce non-ML version 5.0. This process happens simultaneously, where the ML service 3.0 is being developed. When would you integrate the new ML service 3.0 with non-ML version 5.0. The first option is to hold the ML version constant throughout the non-ML iteration. Do note that during the development of the non-ML model, the ML service should be available in some form for making development progress. This may be a dummy service or an yearly version. So we can use ML service version 2.0 for the development of non-ML version 5.0, all the way to integration and deployment. Keeping the ML service constant, provides stability in the development process of the non-ML service. We can then do the next solution release, where we can hold the non-ML version to 5.0 and use the new ML service 3.0. The second option is to adapt a new ML version, as soon as it becomes available during the non-ML cycle. In this case, we will use ML service 2.0 during non-ML 5.0 development, until ML service 3.0 becomes available. The new ML service version is introduced in the middle of the non-ML development or integration cycle. - What are the advantages and disadvantages of adapting the model too soon as it becomes available. Adapting ASAP provides for a faster overall life cycle and quicker time to market. Any issues with the model or the integration would be found earlier. On the other hand, bringing a new version late in the cycle may result in problems and unplanned delays as we roll back and forward. It also requires complex team collaboration between the ML and non-ML teams to make sure that these pieces would work properly when bought together later in the development cycle. Automation can be challenging also if it automatically pulls in a new version of the model, into the development and test cycle leading to breaking of the pipeline. Once again, choose a pattern that best fits your requirements and take care of the shortcomings with proper processes.